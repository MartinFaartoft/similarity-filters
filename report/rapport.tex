% Author: Till Tantau
% Source: The PGF/TikZ manual
\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
%\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs
\usepackage{url}
\usepackage{float}
\usepackage{todonotes}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{pdfpages}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage[T1]{fontenc} % use for allowing < and > in cleartext
\usepackage{fixltx2e}    % use for textsubscript
\usepackage[linesnumbered,boxed,ruled]{algorithm2e}
% \newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\left(#1\right)}}
\newcommand{\BigO}[1]{\ensuremath{\mathop{}\mathopen{}\mathcal{O}\mathopen{}\left(#1\right)}}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  %title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\bibliographystyle{plain}
\begin{document}
\date{May 21st 2014}
\title{Similarity Filters\\A Survey}

\author{Marcus Gregersen\\
\texttt{mabg@itu.dk}
\and Martin Faartoft\\
\texttt{mlfa@itu.dk}
\and Rick Marker\\
\texttt{rdam@itu.dk}}
%TODO vejleder og institut
\clearpage\maketitle
\thispagestyle{empty}
\setcounter{page}{1}
\begin{abstract}
The abstract goes here
\end{abstract}

\newpage

\section{Introduction}
% Marcus: Copy paste fra Pagh, men jeg synes det spiller godt.
In this report we investigate the following problem in data structures:
Given a set $S$ of binary vectors (e.g. 32-bit words) create a data structure that given a query vector $x$ determines if there exists a vector in $S$ that is a factor of \textit{k} close to x.

Different approaches of solving the similiarity search problem exists and in this report we will investigate two different approaches introduced by XX and YY. \todo{Indsæt XX og YY}
Both leverages on the properties of standard bloom filters.

% Begræns problemet
In this report we focus on the special case of similarity search were the elements in the set $S$ is bit-vectors $\{0,1\}^d$. Futhermore we choose the 'closeness' metric to be the Hamming distance.

This report is structered in the following way. In the rest of this section we will establish a baseline. In section XX YY ZZ\todo{Indsæt når vi har skrevet mere}

\subsection{Definitions}
\begin{description}
\item \textbf{Bloom Filter}

A standard bloom filter is a space effient probabilistic data structure that is able to answer whether some element $x$ is member a set $s$ with high certainty.

The bloom filter works by hashing elements into serval indicies in a bit vector. The bit-vector is zero initialized, and when elements are added to the bloom filter the indices in the bit-vector that the element is mapped to are set to 1.

When querying the bloom filter, whether some element $x$ is member of a set, the element is hashed to indicies in the bit-vector, and every value at these indicies has to be set to 1.


\item \textbf{Locality Sensitive Hashing}

We want to be able to hash elements that are similar to each other into the same bins with high probability. We have choosen the bit sampling method \todo{Ref. wiki} in which we define one LSH function as a number of hash functions $l$ that maps an input of high dimensionality into an output vector of length $l$.

% Marcus siger: Skal vi gå mere i detaljer her. Vi kan jo godt tegne vores mapping fra Input til LSH til bloom filter, men hører denne detalje til her eller under "Vores idéer" ?

% TODO 2 paragraffer om LSH i bit-vector context

\item \textbf{K-closeness}
  \begin{itemize}
    \item If a vector $y$ in $S$ differs from $x$ in at most $k$ bits, it is $k$-close to $x$. The data structure must return “close”.
    \item If every vector $y$ in $S$ differs from $x$ in at least $2k$ bits, there is no vector that is $k$-close to $x$. We would like the data structure to return “not close”.
    \item In all other cases, i.e. when the distance to the nearest vector is between $k+1$ and $2k-1$, the data structure can give any answer it likes.
  \end{itemize}

\end{description}
\subsection{Naïve implementation}
\todo{Hvor skal dette afsnit være}
%1 query / n*d^k inserts ELLER 1 insert, n*d^k querys



%     False Negatives (skal det være her?)

%     Hamming afstand
%     bit vektorer af længde L



\section{Related work} % Ideer fra related works

\subsection{Distance-Sensitive Bloom Filters}
Kirsch and Mitzenmacher propose in the paper 'Distance-Sensitive Bloom Filters'\cite{paper:harvard} a novel way of using Bloom filters. The aim is to expand upon classical Bloom filters, enabling them to answer the question: "Does a set contain an element similar to a given element?". They note that such a data structure has a number of practical uses, if it can be made sufficiently effective in both time and space.

The way they accomplish this is by using locality sensitive hashing algorithms (TODO REF), such that two elements that are sufficiently similar will, with a high probability, hash to the same value. They also use a partitioned Bloom filter, which is a like a standard Bloom filter except each locality sensitive hashing algorithm maps into its own bit array, instead of all the hashing algorithms share the same bit array.

When querying the Bloom filter for an approximate match, the element is hashed with all the hashing algorithms, and the corresponding indiceses are checked. If there are more bits, than a specified threshold (T), that is set to 1, it returns that the data contains an element that is close to the query element. The use of a threshold is the reason why it is possible to have false positives using this data structure.

A disadvantage to this approach, compared to a classical Bloom filter, is that it introduces the possibility of false negatives.

% Hvordan adskiller det sig fra normal bloom filters, hvor du har et threshold, t




\subsection{Kinesere}
The paper written by [TODO] takes a different approach than [TODO ref mitz]. They use a standard Bloom Filter data structure, but with LSH in place of ordinary hash functions - they call this a 'Locality Sensitive Bloom Filter'. This 'naive' approach, has a high probability of both False Positives and False Negatives, so they augment this with additional data structures.

Minimizing False Positives:
Every time an element $q$ is checked for approximate membership, the LSBF is checked. If every bit in the array that $q$ hashes to is set to $1$, that could mean one of two things.
1) An element $p$ is in the LSBF, that is approximately close to $q$ (a true positive)
2) Multiple elements in the LSBF, together, have set the bits to $1$, and no single element is approximately close to $q$. (a false positive).

To minimize the probability of a FP, a Verification Scheme Bloom Filter is maintained as follows: Every time an element is added to the LSBF, the bit positions that are set to $1$ by that element, are encoded and added to a separate, standard Bloom Filter (the Verification Scheme). Now when the LSBF would answer 'yes' to an AMQ [TODO define], the Verification Scheme is queried to check if all the $1$ bits in the LSBF was due to any single element. If the Verification Scheme answer 'no', then a FP is detected in the LSBF, and 'no' is answered to the AMQ. However, the Verification Scheme is also prone to FP, since this a property of Bloom Filters, so this approach only servers to reduce the probability of FP, not eliminate them.

Minimizing False Negatives:
They use a method called Active Overflowed Scheme, which utilizes the property of the locality sensitive hashing algorithms that proximate elements will be stored close to each other. The idea is that a pair of close elements may not be hashed to the same value, but instead be put in adjacent bins in the bit array. So when querying, instead of just looking at the bits which represents the hashed element, you also check the $t$ closest bits to either side. $t$ will depend on the price of false positives compared to false negatives as this approach will introduce more false positives.

\section{Theory} % Dette afsnit skal nok hedde noget andet

%valg af T, k, m', n', n
  %pulje af hashfunktioner (seed til random generator)
  %beregn true/false positives og true/false negatives
%find epsilon og sigma fra ovenstående
%diskutér false positives (sandsynlighed)
%diskutér false negatives (kan de elimineres?)



\section{Experiments}
%tegn nogle grafer

% Forsøg at finde variable eksperimentelt
% Forsøg at variér closeness/farness i kandidater og tegn FP og FN-rate som funktion af disse


\section{Conclusion}
\subsection{Suggested Improvements}

\newpage

\begin{thebibliography}{}

\bibitem{paper:harvard}
Adam Kirsch, Michael Mitzenmacher
Distance-Sensitive Bloom Filters

      %Sådan her ref'er man en URL
      %\bibitem{lit:json}
      %\url{http://tools.ietf.org/html/rfc4627}
      %Retrieved: 2013-05-02
\end{thebibliography}

%code in appendix
\section*{Appendix}
%\lstinputlisting[language=Python]{../tools/size_estimator.py}


\end{document}
